// package grpc_clients_test

// import (
// 	"context"
// 	"log"
// 	"net"
// 	"testing"

// 	"github.com/chud-lori/go-boilerplate/infrastructure/grpc_clients"
// 	pb "github.com/chud-lori/go-boilerplate/proto"
// 	"github.com/stretchr/testify/require"
// 	"google.golang.org/grpc"
// 	"google.golang.org/grpc/test/bufconn"
// )

// // Buffer size for in-memory gRPC server
// const bufSize = 1024 * 1024

// var lis *bufconn.Listener

// // Start a mock gRPC server using bufconn
// func init() {
// 	lis = bufconn.Listen(bufSize)
// 	s := grpc.NewServer()
// 	pb.RegisterMailServer(s, &mockMailServer{})
// 	go func() {
// 		if err := s.Serve(lis); err != nil {
// 			log.Fatalf("Server exited with error: %v", err)
// 		}
// 	}()
// }

// // custom dialer for bufconn
// func bufDialer(context.Context, string) (net.Conn, error) {
// 	return lis.Dial()
// }

// // mock implementation of MailServer
// type mockMailServer struct {
// 	pb.UnimplementedMailServer
// }

// func (s *mockMailServer) SendMail(ctx context.Context, req *pb.MailRequest) (*pb.MailReply, error) {
// 	if req.Email == "" {
// 		return nil, grpc.Errorf(3, "email is required") // INVALID_ARGUMENT
// 	}
// 	return &pb.MailReply{Message: "Mail sent to " + req.Email}, nil
// }

// // The actual test
// func TestSendGrpcMailWithOpts(t *testing.T) {
// 	t.Run("success", func(t *testing.T) {
// 		err := grpc_clients.SendGrpcMailWithOpts("test@example.com", "hello", grpc.WithContextDialer(bufDialer), grpc.WithInsecure())
// 		require.NoError(t, err)
// 	})

// 	t.Run("missing email triggers error", func(t *testing.T) {
// 		err := grpc_clients.SendGrpcMailWithOpts("", "hello", grpc.WithContextDialer(bufDialer), grpc.WithInsecure())
// 		require.Error(t, err)
// 	})
// }
